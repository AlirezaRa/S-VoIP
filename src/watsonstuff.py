import gtranslate
import subprocess
import ConfigParser
import urllib
import os
import speechRecognition as sr


configParser = ConfigParser.RawConfigParser()
configFilePath = r'../config.txt'
configParser.read(configFilePath)
BM = configParser.get('System', 'BM_TEXT2SPEECH_LINK')


def callWatson(thing):
    # It retrieves the .ogg file that's being generated by the app on Bluemix.
    # Then cvlc streams it through the messanger that's already loaded with
    # PULSE_SOURCE variable (should have used with main.loadNull())
    urllib.urlretrieve(BM + "synthesize?text=" + str(thing),
                       "../data/temp/eng.ogg")
    if not os.path.exists("../data/temp/eng.ogg"):
        print "Something went wrong with Watson synthesizing your text"
        return False
    p = subprocess.Popen(str("PULSE_SINK=null cvlc --no-repeat " + 
                             "--play-and-exit ../data/temp/eng.ogg"),
                             shell=True)
    p.communicate()


def mainWatson():
    # The front-end interface which is called from main.py
    thing = str(raw_input("Say Something (w to exit): "))
    while thing != 'w':
        callWatson(thing)
        thing = str(raw_input("Say Something (w to exit): "))


def mainSpeech():
    # For the sake of accuracy, sox records each of your sentence and saves it
    # in temp. speechRecognition then returns a string of the content. That is
    # passed to Watson. Since sox has to record only one sentence, it needs to
    # be killed at some point. It would be killed if you press 'y' and hit
    # enter by @stop variable. @decision is required to prevent sox record and
    # save stuff if not wanted.
    decision = str(raw_input("Are you sure? (y/n) "))
    while decision == 'y':
        print "Say an English sentence."
        subprocess.Popen(str("sox -t alsa default ../data/temp/recording.wav"),
                         shell=True)
        print "*******"
        stop = str(raw_input("Enter 'y' when you've finished with a sentence"))
        print "*******"
        if stop == 'y':
            pid = subprocess.Popen("pkill sox", shell=True)
            pid.communicate()
            yousaid = sr.sRecognizer()
        if yousaid:
            callWatson(yousaid)
            decision = str(raw_input("Try it again? (y/n) "))
        elif not yousaid:
            print "Speech is unintelligible"
            decision = str(raw_input("Try it again? (y/n) "))


def saySpanish(thing):
    # Same as callWatson. The only difference is that gtranslate translates
    # @thing into Spanish!
    trtemp = gtranslate.translate(thing, "es", "en")
    urllib.urlretrieve(BM + "synthesize?text=" + str(trtemp) +
                       "&voice=VoiceEsEsEnrique", "../data/temp/es.ogg")
    if not os.path.exists("../data/temp/es.ogg"):
        print "Something went wrong with Watson synthesizing your text"
        return False
    p = subprocess.Popen(str("PULSE_SINK=null cvlc --no-repeat " + 
                             "--play-and-exit ../data/temp/es.ogg"), + 
                             shell=True)
    p.communicate()


def mainSpanish():
    thing = str(raw_input("Say Something (wes to exit): "))
    while thing != "wes":
        saySpanish(thing)
        thing = str(raw_input("Say Something (wes to exit): "))


def mainSpanishSpeech():
    decision = str(raw_input("Are you sure? (y/n) "))
    while decision == 'y':
        print "**********"
        print "Say an English sentence."
        print "**********"
        subprocess.Popen(str("sox -t alsa default ../data/temp/recording.wav"),
                         shell=True)
        print "**********"
        stop = str(raw_input("Enter 'y' when you've finished with a sentence"))
        print "**********"
        if stop == 'y':
            pid = subprocess.Popen("pkill sox", shell=True)
            pid.communicate()
            yousaid = sr.sRecognizer()
            if yousaid:
                saySpanish(yousaid)
                decision = str(raw_input("Try it again? (y/n) "))
            elif not yousaid:
                print "Speech is unintelligible"
                decision = str(raw_input("Try it again? (y/n) "))
